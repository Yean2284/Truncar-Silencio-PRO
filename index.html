<!DOCTYPE html>
<html lang="es">
<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      window.adsbygoogle = window.adsbygoogle || [];
    </script>
    <script>
    function showInterstitial() {
      try {
          if (window.adsbygoogle) {
            adsbygoogle.push({
              google_ad_client: "ca-app-pub-3940256099942544",
              enable_page_level_ads: true
            });
          }
      } catch(e) { console.log("Ad error ignored"); }
    }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Truncar Silencio PRO</title>
    <meta name="google-adsense-account" content="ca-app-pub-3940256099942544">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-app-pub-3940256099942544" crossorigin="anonymous"></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#7c3aed">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.all.min.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { background: #0f172a; color: white; font-family: sans-serif; -webkit-tap-highlight-color: transparent; }
        .card-pro { background: rgba(30, 41, 59, 0.85); border: 1px solid rgba(168, 85, 247, 0.3); backdrop-filter: blur(15px); }
        .progress-bar-fill { transition: width 0.3s ease-in-out; }
    </style>
</head>
<body>
    <div id="root"></div>

<script type="text/babel">
        const { useState, useRef, useEffect } = React;

        function App() {
            const [file, setFile] = useState(null);
            const [isProc, setIsProc] = useState(false);
            const [prog, setProg] = useState(0);
            const [url, setUrl] = useState(null);
            const audioCtx = useRef(null);

            const THRESHOLD = -30; 
            const DURATION = 0.6;

            const handleDownload = (e) => {
                e.preventDefault();
                if (!url) return;
                const link = document.createElement('a');
                link.href = url;
                link.download = 'audio_sin_silencio.mp3';
                document.body.appendChild(link);
                link.click();
                setTimeout(() => document.body.removeChild(link), 100);
            };

            // Funci√≥n auxiliar para convertir Float32 a Int16 (necesario para MP3)
            // sin crear arrays gigantes
            const convertToInt16 = (float32Array) => {
                const l = float32Array.length;
                const i16 = new Int16Array(l);
                for(let i=0; i<l; i++) {
                    const v = Math.max(-1, Math.min(1, float32Array[i]));
                    i16[i] = v < 0 ? v * 0x8000 : v * 0x7FFF;
                }
                return i16;
            };

            const processAudio = async () => {
                if (!file) return;
                setIsProc(true);
                setProg(1);
                
                if (url) URL.revokeObjectURL(url);
                setUrl(null);

                try {
                    // 1. Setup AudioContext
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!audioCtx.current) audioCtx.current = new AudioContext();
                    if (audioCtx.current.state === 'suspended') await audioCtx.current.resume();

                    setProg(5);

                    // 2. Decodificar (Esto es lo √∫nico que gasta RAM ahora)
                    const arrayBuffer = await file.arrayBuffer();
                    const buf = await audioCtx.current.decodeAudioData(arrayBuffer);
                    const data = buf.getChannelData(0); 
                    const rate = buf.sampleRate;
                    
                    const limit = Math.pow(10, THRESHOLD / 20);
                    const minSilence = Math.floor(DURATION * rate);
                    
                    // 3. Preparar Encoder MP3
                    const mp3enc = new lamejs.Mp3Encoder(1, rate, 128);
                    const chunks = [];
                    
                    // Buffer temporal peque√±o para codificar
                    // NO creamos un array "output" gigante, codificamos al vuelo.
                    
                    let currentChunk = [];
                    const CHUNK_SIZE = 1152; // Tama√±o de bloque mp3 est√°ndar
                    
                    let i = 0;
                    let lastUpdate = Date.now();
                    const totalLen = data.length;

                    // Bucle principal optimizado
                    while (i < totalLen) {
                        
                        // L√≥gica de detecci√≥n de silencio
                        if (Math.abs(data[i]) < limit) {
                            let s = i;
                            // Buscar fin del silencio
                            while (i < totalLen && Math.abs(data[i]) < limit) i++;
                            
                            const silenceLen = i - s;
                            
                            if (silenceLen >= minSilence) {
                                // Es silencio largo: IGNORAR (Truncar), insertar solo una pizca
                                // para suavizar (0.05s)
                                const bridge = Math.floor(0.05 * rate);
                                for (let k = 0; k < bridge; k++) currentChunk.push(0);
                            } else {
                                // Es silencio corto: MANTENER
                                for (let k = s; k < i; k++) currentChunk.push(data[k]);
                            }
                        } else {
                            // Es sonido: MANTENER
                            currentChunk.push(data[i]);
                            i++;
                        }

                        // Si el buffer temporal est√° lleno, codificar a MP3 y limpiar RAM
                        while (currentChunk.length >= CHUNK_SIZE) {
                            const subarray = new Float32Array(currentChunk.slice(0, CHUNK_SIZE));
                            currentChunk = currentChunk.slice(CHUNK_SIZE); // Mantener el resto
                            
                            const i16 = convertToInt16(subarray);
                            const mp3buf = mp3enc.encodeBuffer(i16);
                            if (mp3buf.length > 0) chunks.push(mp3buf);
                        }

                        // Actualizar UI y liberar hilo principal cada 500ms
                        // (Evita el "Oh No" por timeout)
                        if (Date.now() - lastUpdate > 500) {
                            const p = Math.floor((i / totalLen) * 95);
                            setProg(p);
                            await new Promise(r => setTimeout(r, 0));
                            lastUpdate = Date.now();
                        }
                    }

                    // Procesar lo que quede en el buffer
                    if (currentChunk.length > 0) {
                         const subarray = new Float32Array(currentChunk);
                         const i16 = convertToInt16(subarray);
                         const mp3buf = mp3enc.encodeBuffer(i16);
                         if (mp3buf.length > 0) chunks.push(mp3buf);
                    }

                    // Finalizar MP3
                    const mp3last = mp3enc.flush();
                    if (mp3last.length > 0) chunks.push(mp3last);

                    // Crear Blob
                    const blob = new Blob(chunks, { type: 'audio/mp3' });
                    setUrl(URL.createObjectURL(blob));
                    setProg(100);
                    
                    showInterstitial();

                } catch (e) { 
                    console.error(e);
                    alert("Error: Memoria insuficiente. Intenta con un audio m√°s corto o de menor calidad."); 
                }
                setIsProc(false);
            };

            return (
                <div className="min-h-screen flex flex-col items-center p-6 bg-[#090e1a]">
                    <div className="w-full max-w-md card-pro p-8 rounded-[2.5rem] mt-10 shadow-2xl border-t border-white/10">
                        <h1 className="text-center text-2xl font-black mb-8 text-purple-400 italic uppercase tracking-tighter">Truncar Silencio Pro</h1>
                        
                        <div className="border-2 border-dashed border-purple-500/20 rounded-3xl p-8 text-center mb-6 bg-slate-900/50">
                            <input type="file" onChange={e => {setFile(e.target.files[0]); setUrl(null);}} className="hidden" id="aud" accept="audio/*" />
                            <label htmlFor="aud" className="cursor-pointer block">
                                <span className="text-4xl block mb-2">{file ? "‚úÖ" : "üìÅ"}</span>
                                <span className="text-xs text-purple-200 font-bold uppercase truncate block">
                                    {file ? file.name : "Seleccionar Audio"}
                                </span>
                            </label>
                        </div>

                        {isProc && (
                            <div className="mb-6">
                                <div className="w-full bg-slate-900 rounded-full h-1.5 overflow-hidden">
                                    <div className="bg-purple-500 h-full progress-bar-fill" style={{ width: `${prog}%` }}></div>
                                </div>
                                <p className="text-center text-[10px] mt-2 text-purple-300 font-bold">{prog}% COMPLETADO</p>
                            </div>
                        )}

                        {!url ? (
                            <button onClick={processAudio} disabled={!file || isProc} className="w-full bg-purple-600 hover:bg-purple-500 disabled:opacity-30 py-5 rounded-3xl font-black text-lg shadow-lg transition-all text-white border-b-4 border-purple-800">
                                {isProc ? "TRABAJANDO..." : "ELIMINAR SILENCIOS"}
                            </button>
                        ) : (
                            <div className="space-y-4 text-center">
                                <button onClick={handleDownload} className="w-full bg-emerald-600 hover:bg-emerald-500 py-5 rounded-3xl font-black text-lg block shadow-lg border-b-4 border-emerald-800 text-white uppercase">
                                    DESCARGAR MP3 ‚úÖ
                                </button>
                                <button onClick={() => {setUrl(null); setProg(0); setFile(null);}} className="text-[10px] text-gray-500 uppercase font-bold">Procesar otro</button>
                            </div>
                        )}
                    </div>

                    <div className="mt-12 text-center pb-10">
                        <p className="text-[10px] text-gray-500 uppercase font-bold tracking-[0.3em] mb-1">Desarrollado por</p>
                        <p className="text-md font-black text-purple-100 tracking-widest uppercase">YEAN CARLOS GODOY GONZALEZ</p>
                        <p className="text-[9px] text-gray-600 font-bold mt-2">¬© 2025 TODOS LOS DERECHOS RESERVADOS</p>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
